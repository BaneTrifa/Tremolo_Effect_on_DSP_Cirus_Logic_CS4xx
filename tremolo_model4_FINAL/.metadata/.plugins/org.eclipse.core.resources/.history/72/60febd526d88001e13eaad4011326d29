_TREMOLO_ASM

	.if defined (_TREMOLO_ASM)

_BLOCK_SIZE .equ 16	

	.public _tremoloLeft
	.public _tremoloRight
    .extern _generate_sine
    .extern _tremolo_postGain
    .extern _limiterThreshold
	
X_SECTION   .xdata_ovly

PI	.dw 0.78539816339725	// PI scaled by 4 (2 bits)


L_SECTION   .data_ovly

phLeft .bss (1)
phRight .bss (1)
PH_STEP .dw (0x00015cf7), (0x51db94e7)	// 0.0000416

	.code_ovly

  # x1 - parameter phase, DO NOT MODIFY x1, a2, i2 and i3
_lfo:	// a0 return value
	
	//fract_pi = (DSPaccum)PI;	scaled by 4
	x0 = xmem[PI]
	
	//accum_pi = fract_pi * phase;
	a0 = x0 * x1
	//accum_pi <<= 3;
	a0 = a0 << 1	// resacle by 4
	a0 = a0 << 1
	a0 = a0 << 1	// multiply by 2

	//accum_pi = (DSPaccum)gen_sin(accum_pi); a0 is return value from gen_sin
	call _generate_sine
	//accum_pi >>= 1; 
	a0 = a0 >> 1 // by formula multiply by 0.5

	
	//accum_pi += (DSPaccum)0.5;
	a1 =(0x4000) // const 0.5
	a0 = a0 + a1
	
	ret	
	
	
	 # i4 - parameter pointer to in channel (left)
	 # i5 - parameter pointer to out channel (Ls)
_tremoloLeft: // DO NOT MODIFY i2 and i3

	b0 = xymem[phLeft]
	#b0h = xmem[phLeft]	// load phase for left channel
	#b0l = ymem[phLeft]
	x1 = b0				// PH
	
	//for (i = 0; i < BLOCK_SIZE; ++i)
	do(_BLOCK_SIZE),>loop
		//accum_lfo = (DSPaccum) lfo(ph); -> return value is a0
		call _lfo
		
		//accum_lfo = (DSPaccum)1.0 - accum_lfo;
		ufixed16(a1) = (0x8000)	// a1 = 1.0
		a1 = a1 - a0
		
		//accum_lfo >>= 1;
		a1 = a1 >> 1
		
		//accum_lfo = (DSPfract)accum_lfo * in;
		x0 = a1
		y0 = ymem[i4]; i4 += 1
		a1 = x0 * y0
		//accum_lfo = (DSPfract)accum_lfo * postgain;
		x0 = a1
		y0 = xmem[_tremolo_postGain]
		a1 = x0 * y0
		
		//accum_lfo <<= 1;
		a1 = a1 << 1
		
		// *output = saturation_tremolo(accum_lfo);
		b1 = xmem[_limiterThreshold]
		if (b1 < a1) a1 = b1
		
		b1 = -b1
		if (b1 > a1) a1 = b1
		
		ymem[i5] = a1; i5 += 1
		
		// *accum_ph += (DSPaccum)PH_STEP;
		b0 = xymem[phLeft]	// load phase for left channel (accum_ph)
		#b0h = xmem[phLeft]	
		#b0l = ymem[phLeft]
		
		a0 = xymem[PH_STEP]
		#a0h = xmem[PH_STEP]
		#a0l = ymem[PH_STEP]
		
		b0 = b0 + a0
		
		
		//if (*accum_ph >= (DSPaccum)1.0)
		//	*accum_ph -= (DSPaccum)1.0;
		ufixed16(a1) = (0x8000)	// a1 = 1.0
		b0 - a1
		if (b < 0) jmp>write_b0
			b0 = b0 - a1

		//ph = *accum_ph;
%write_b0:	xymem[phLeft] = b0
			#xmem[phLeft] = b0h
			#ymem[phLeft] = b0l
		
%loop:	x1 = b0

	ret


	# i4 - parameter pointer to in channel (left)
	# i5 - parameter pointer to out channel (Ls)
_tremoloRight: // DO NOT MODIFY i2 and i3

	#b0 = xymem[phRight]	// load phase for left channel
	x1 = b0				// PH
	
	//for (i = 0; i < BLOCK_SIZE; ++i)
	do(_BLOCK_SIZE),>loop
		//accum_lfo = (DSPaccum) lfo(ph); -> return value is a0
		call _lfo
		
		//accum_lfo = (DSPaccum)1.0 - accum_lfo;
		ufixed16(a1) = (0x8000)	// a1 = 1.0
		a1 = a1 - a0
		
		//accum_lfo >>= 1;
		a1 = a1 >> 1
		
		//accum_lfo = (DSPfract)accum_lfo * in;
		x0 = a1
		y0 = ymem[i4]; i4 += 1
		a1 = x0 * y0
		//accum_lfo = (DSPfract)accum_lfo * postgain;
		x0 = a1
		y0 = xmem[_tremolo_postGain]
		a1 = x0 * y0
		
		//accum_lfo <<= 1;
		a1 = a1 << 1
		
		// *output = saturation_tremolo(accum_lfo);
		b1 = xmem[_limiterThreshold]
		if (b1 < a1) a1 = b1
		
		b1 = -b1
		if (b1 > a1) a1 = b1
		
		ymem[i5] = a1; i5 += 1
		
		// *accum_ph += (DSPaccum)PH_STEP;
		#b0 = xymem[phRight]	// load accum_ph from L memory
		#a0 = xymem[PH_STEP]
		b0 = b0 + a0
		
		//if (*accum_ph >= (DSPaccum)1.0)
		//	*accum_ph -= (DSPaccum)1.0;
		ufixed16(a1) = (0x8000)	// a1 = 1.0
		b0 - a1
		if (b < 0) jmp>write_phase
			b0 = b0 - a1

%write_phase: #xymem[phRight] = b0

		//ph = *accum_ph;
%loop:	x1 = b0

	ret
	
	.endif